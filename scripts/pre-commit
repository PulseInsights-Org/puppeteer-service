#!/usr/bin/env bash
# =============================================================================
# PRE-COMMIT HOOK â€” puppeteer-service
#
# Runs targeted quality checks on staged files before allowing a commit.
# Install: npm run hooks:install
# Skip (emergencies only): git commit --no-verify
# =============================================================================

set -euo pipefail

# Colors and formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Box-drawing characters
BOX_TL='â•”'
BOX_TR='â•—'
BOX_BL='â•š'
BOX_BR='â•'
BOX_H='â•'
BOX_V='â•‘'
BOX_ML='â• '
BOX_MR='â•£'
INNER_TL='â”Œ'
INNER_TR='â”'
INNER_BL='â””'
INNER_BR='â”˜'
INNER_H='â”€'
INNER_V='â”‚'

WIDTH=64

print_header() {
    local title="$1"
    local pad_len=$(( (WIDTH - ${#title} - 2) ))
    local left_pad=$(( pad_len / 2 ))
    local right_pad=$(( pad_len - left_pad ))
    printf "${BOLD}${BOX_TL}"
    printf '%0.s'"${BOX_H}" $(seq 1 $WIDTH)
    printf "${BOX_TR}${NC}\n"
    printf "${BOLD}${BOX_V}  %-$(( WIDTH - 2 ))s${BOX_V}${NC}\n" "$title"
    printf "${BOLD}${BOX_ML}"
    printf '%0.s'"${BOX_H}" $(seq 1 $WIDTH)
    printf "${MR:-${BOX_MR}}${NC}\n"
}

print_footer() {
    printf "${BOLD}${BOX_BL}"
    printf '%0.s'"${BOX_H}" $(seq 1 $WIDTH)
    printf "${BOX_BR}${NC}\n"
}

print_line() {
    printf "${BOLD}${BOX_V}${NC}  %-$(( WIDTH - 2 ))s${BOLD}${BOX_V}${NC}\n" "$1"
}

print_empty() {
    printf "${BOLD}${BOX_V}${NC}  %-$(( WIDTH - 2 ))s${BOLD}${BOX_V}${NC}\n" ""
}

print_success() {
    printf "\n${GREEN}${BOLD}  âœ“ $1${NC}\n"
}

print_phase() {
    printf "\n${CYAN}${BOLD}  â–¶ Phase $1: $2${NC}\n"
}

print_skip() {
    printf "    ${DIM}â†³ Skipped: $1${NC}\n"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Phase 0: Analyze staged files
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
printf "\n${BLUE}${BOLD}  ðŸ” Pre-commit checks starting...${NC}\n"

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR 2>/dev/null || true)

if [ -z "$STAGED_FILES" ]; then
    print_success "No staged files â€” nothing to check"
    exit 0
fi

# Categorize staged files
STAGED_JS_SRC=""
STAGED_JS_TEST=""
STAGED_JS_ALL=""
STAGED_CONFIG=""
HAS_SRC_CHANGES=false
HAS_TEST_CHANGES=false

while IFS= read -r file; do
    case "$file" in
        src/*.js)
            STAGED_JS_SRC="$STAGED_JS_SRC $file"
            STAGED_JS_ALL="$STAGED_JS_ALL $file"
            HAS_SRC_CHANGES=true
            ;;
        tests/*.js)
            STAGED_JS_TEST="$STAGED_JS_TEST $file"
            STAGED_JS_ALL="$STAGED_JS_ALL $file"
            HAS_TEST_CHANGES=true
            ;;
        server.js)
            STAGED_JS_SRC="$STAGED_JS_SRC $file"
            STAGED_JS_ALL="$STAGED_JS_ALL $file"
            HAS_SRC_CHANGES=true
            ;;
        *.js)
            STAGED_JS_ALL="$STAGED_JS_ALL $file"
            ;;
        *.json|*.yml|*.yaml|.eslintrc*)
            STAGED_CONFIG="$STAGED_CONFIG $file"
            ;;
    esac
done <<< "$STAGED_FILES"

STAGED_JS_ALL=$(echo "$STAGED_JS_ALL" | xargs)
STAGED_JS_SRC=$(echo "$STAGED_JS_SRC" | xargs)
STAGED_JS_TEST=$(echo "$STAGED_JS_TEST" | xargs)

printf "    ${DIM}Staged: %d file(s) | JS source: %d | JS test: %d${NC}\n" \
    "$(echo "$STAGED_FILES" | wc -l | xargs)" \
    "$(echo "$STAGED_JS_SRC" | wc -w | xargs)" \
    "$(echo "$STAGED_JS_TEST" | wc -w | xargs)"

FAILED=false
FAIL_PHASE=""
FAIL_DETAILS=""
FAIL_NEXT_STEPS=""

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Phase 1: Secret Detection
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
print_phase "1" "Secret Detection"

SECRET_PATTERNS='(SUPABASE_SERVICE_ROLE_KEY|SUPABASE_URL|EC2_SSH_KEY|AWS_SECRET|api[_-]?key|secret[_-]?key|password)\s*[=:]\s*['\''"][^'\''"]{8,}'

SECRETS_FOUND=""
while IFS= read -r file; do
    # Skip .env.example and test files
    case "$file" in
        *.example|*.test.js|tests/*) continue ;;
    esac
    MATCH=$(git diff --cached -U0 "$file" 2>/dev/null | grep -iE "$SECRET_PATTERNS" 2>/dev/null || true)
    if [ -n "$MATCH" ]; then
        SECRETS_FOUND="$SECRETS_FOUND\n  $file:\n$MATCH"
    fi
done <<< "$STAGED_FILES"

if [ -n "$SECRETS_FOUND" ]; then
    FAILED=true
    FAIL_PHASE="Phase 1 â€” Potential Secrets Detected"
    FAIL_DETAILS="Possible credentials or API keys found in staged changes:$SECRETS_FOUND"
    FAIL_NEXT_STEPS="1. Remove secrets from source code\n  2. Use environment variables instead (.env file)\n  3. If false positive, add to .gitignore or adjust pattern"
else
    print_success "No secrets detected"
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Phase 2: Lint (only if JS files staged)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [ "$FAILED" = false ]; then
    print_phase "2" "Lint Check"

    if [ -z "$STAGED_JS_ALL" ]; then
        print_skip "No JavaScript files staged"
    else
        # Check if eslint is available
        if npx eslint --version > /dev/null 2>&1; then
            LINT_OUTPUT=$(npx eslint $STAGED_JS_ALL --no-error-on-unmatched-pattern 2>&1 || true)
            LINT_EXIT=$?

            if echo "$LINT_OUTPUT" | grep -qE "[0-9]+ error"; then
                FAILED=true
                FAIL_PHASE="Phase 2 â€” Lint Errors"
                FAIL_DETAILS="$LINT_OUTPUT"
                FAIL_NEXT_STEPS="1. Run: npx eslint $STAGED_JS_ALL --fix\n  2. Review and stage fixes: git add <fixed-files>\n  3. Retry: git commit"
            else
                print_success "Lint passed"
            fi
        else
            print_skip "ESLint not installed (run: npm install)"
        fi
    fi
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Phase 3: Targeted Tests (only if src/ or test/ files staged)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [ "$FAILED" = false ]; then
    print_phase "3" "Targeted Tests"

    if [ "$HAS_SRC_CHANGES" = false ] && [ "$HAS_TEST_CHANGES" = false ]; then
        print_skip "No source or test files changed"
    else
        # Build list of related test files using jest --findRelatedTests
        TEST_TARGET=""

        if [ "$HAS_SRC_CHANGES" = true ] && [ -n "$STAGED_JS_SRC" ]; then
            TEST_TARGET="$STAGED_JS_SRC"
        fi

        if [ -n "$STAGED_JS_TEST" ]; then
            TEST_TARGET="$TEST_TARGET $STAGED_JS_TEST"
        fi

        TEST_TARGET=$(echo "$TEST_TARGET" | xargs)

        if [ -n "$TEST_TARGET" ]; then
            printf "    ${DIM}Running tests related to: %s${NC}\n" "$TEST_TARGET"
            TEST_OUTPUT=$(npx cross-env NODE_ENV=test npx jest --findRelatedTests $TEST_TARGET --passWithNoTests --forceExit 2>&1 || true)
            TEST_EXIT_CODE=$?

            # Check for test failures (look for "Tests:" summary line with "failed")
            if echo "$TEST_OUTPUT" | grep -qE "Tests:.*failed"; then
                FAILED=true
                # Extract just the failed test names
                FAILED_TESTS=$(echo "$TEST_OUTPUT" | grep -E "(FAIL|âœ•|âœ—|Ã—)" | head -20)
                FAIL_PHASE="Phase 3 â€” Test Failures"
                FAIL_DETAILS="$FAILED_TESTS"
                FAIL_NEXT_STEPS="1. Run: npx cross-env NODE_ENV=test npx jest --findRelatedTests $TEST_TARGET\n  2. Fix failing tests\n  3. Stage fixes and retry: git commit"
            else
                # Count passing tests
                PASS_COUNT=$(echo "$TEST_OUTPUT" | grep -oE "Tests:.*[0-9]+ passed" | grep -oE "[0-9]+ passed" || echo "0 passed")
                print_success "Tests passed ($PASS_COUNT)"
            fi
        else
            print_skip "No testable files identified"
        fi
    fi
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Phase 4: Coverage Check (only if src/ files staged)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [ "$FAILED" = false ]; then
    print_phase "4" "Coverage Verification"

    if [ "$HAS_SRC_CHANGES" = false ]; then
        print_skip "No source files changed â€” coverage check not needed"
    else
        # Run coverage on related tests only, with JSON output
        COV_OUTPUT=$(npx cross-env NODE_ENV=test npx jest --findRelatedTests $STAGED_JS_SRC \
            --coverage --coverageReporters=json-summary \
            --passWithNoTests --forceExit 2>&1 || true)

        # Check if coverage-summary.json was generated
        COV_SUMMARY="coverage/coverage-summary.json"

        if [ -f "$COV_SUMMARY" ]; then
            # Parse coverage percentages using node
            COV_CHECK=$(node -e "
                const cov = require('./$COV_SUMMARY');
                const total = cov.total;
                const lines = total.lines.pct;
                const branches = total.branches.pct;
                const funcs = total.functions.pct;
                const stmts = total.statements.pct;
                const threshold = 85;
                const pass = lines >= threshold && branches >= threshold && funcs >= threshold && stmts >= threshold;
                console.log(JSON.stringify({ pass, lines, branches, funcs, stmts, threshold }));
            " 2>/dev/null || echo '{"pass":true,"lines":0,"branches":0,"funcs":0,"stmts":0,"threshold":85}')

            COV_PASS=$(echo "$COV_CHECK" | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'));process.stdout.write(String(d.pass))")
            COV_LINES=$(echo "$COV_CHECK" | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'));process.stdout.write(String(d.lines))")
            COV_BRANCHES=$(echo "$COV_CHECK" | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'));process.stdout.write(String(d.branches))")
            COV_FUNCS=$(echo "$COV_CHECK" | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'));process.stdout.write(String(d.funcs))")
            COV_STMTS=$(echo "$COV_CHECK" | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'));process.stdout.write(String(d.stmts))")

            if [ "$COV_PASS" = "false" ]; then
                FAILED=true
                FAIL_PHASE="Phase 4 â€” Coverage Below 85% Threshold"
                FAIL_DETAILS="Coverage for changed files:\n    Statements: ${COV_STMTS}%\n    Branches:   ${COV_BRANCHES}%\n    Functions:  ${COV_FUNCS}%\n    Lines:      ${COV_LINES}%"
                FAIL_NEXT_STEPS="1. Run: npm run test:coverage  (see full report)\n  2. Open: coverage/lcov-report/index.html\n  3. Add tests for uncovered lines\n  4. Stage test files and retry: git commit"
            else
                print_success "Coverage OK (lines: ${COV_LINES}%, branches: ${COV_BRANCHES}%, funcs: ${COV_FUNCS}%, stmts: ${COV_STMTS}%)"
            fi
        else
            printf "    ${DIM}â†³ Coverage summary not generated (tests may have been skipped)${NC}\n"
            print_success "Coverage check skipped (no applicable tests)"
        fi
    fi
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Result
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
printf "\n"

if [ "$FAILED" = true ]; then
    print_header "PRE-COMMIT FAILED: $FAIL_PHASE"
    print_empty
    # Print failure details line by line
    echo -e "$FAIL_DETAILS" | while IFS= read -r line; do
        print_line "$line"
    done
    print_empty
    printf "${BOLD}${BOX_V}${NC}  ${INNER_TL}"
    printf '%0.s'"${INNER_H}" $(seq 1 $(( WIDTH - 6 )))
    printf "${INNER_TR}  ${BOLD}${BOX_V}${NC}\n"
    printf "${BOLD}${BOX_V}${NC}  ${INNER_V}  ${BOLD}NEXT STEPS:${NC}%-$(( WIDTH - 20 ))s${INNER_V}  ${BOLD}${BOX_V}${NC}\n" ""
    echo -e "$FAIL_NEXT_STEPS" | while IFS= read -r line; do
        printf "${BOLD}${BOX_V}${NC}  ${INNER_V}  %-$(( WIDTH - 8 ))s${INNER_V}  ${BOLD}${BOX_V}${NC}\n" "$line"
    done
    printf "${BOLD}${BOX_V}${NC}  ${INNER_BL}"
    printf '%0.s'"${INNER_H}" $(seq 1 $(( WIDTH - 6 )))
    printf "${INNER_BR}  ${BOLD}${BOX_V}${NC}\n"
    print_empty
    print_line "${DIM}To skip (emergencies only): git commit --no-verify${NC}"
    print_footer
    printf "\n"
    exit 1
else
    printf "${GREEN}${BOLD}  âœ… All pre-commit checks passed${NC}\n\n"
    exit 0
fi
